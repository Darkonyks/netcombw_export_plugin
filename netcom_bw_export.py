# -*- coding: utf-8 -*-
"""
/***************************************************************************
 netcom_bw_export
                                 A QGIS plugin
 netcom_bw_export
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-11-28
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Darko Nedic
        email                : nedic.darko@geodigit.rs
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QMessageBox
from qgis.core import QgsProject, QgsVectorLayer, QgsVectorFileWriter, QgsFeature, QgsField, QgsWkbTypes, QgsFeatureRequest, QgsCoordinateTransformContext
import os
import os.path
import shutil

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .netcom_bw_export_dialog import netcom_bw_exportDialog
# Import GDB exporter
from .export_gdb import GDBExporter


class netcom_bw_export:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'netcom_bw_export_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&netcom_bw_export')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('netcom_bw_export', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/netcom_bw_export/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'NetcomBW export'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&netcom_bw_export'),
                action)
            self.iface.removeToolBarIcon(action)


    def populate_job_dropdown(self):
        """Populate the job dropdown with jobs from the 'job' layer"""
        # Clear existing items
        self.dlg.comboBox_job.clear()
        
        # Find the job layer
        layers = QgsProject.instance().mapLayers()
        job_layer = None
        for layer_id, layer in layers.items():
            if layer.name().lower() == 'job':
                job_layer = layer
                break
        
        if not job_layer or not job_layer.isValid():
            self.dlg.comboBox_job.addItem("No job layer found", None)
            return
        
        # Get all jobs and add to dropdown
        for feature in job_layer.getFeatures():
            job_id = feature['id']
            beschreibung = feature['beschreibung'] if feature['beschreibung'] else ''
            display_text = f"{job_id} - {beschreibung}"
            self.dlg.comboBox_job.addItem(display_text, job_id)
    
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = netcom_bw_exportDialog()

        # Populate job dropdown
        self.populate_job_dropdown()
        
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Get the job_id value from the dialog
            job_id = self.dlg.get_job_id()
            
            # Get the selected output folder
            output_folder = self.dlg.get_output_folder()
            
            if not output_folder:
                QMessageBox.warning(
                    self.iface.mainWindow(),
                    'Warning',
                    'No output folder selected.'
                )
                return
            
            # List to collect export results
            export_results = []
            
            # Define layers to export (name, export_function)
            layers_to_export = [
                ('PUNKT', self.export_punkt_layer),
                ('ROHRMUFFE', self.export_rohrmuffe_layer),
                ('MESSPUNKT', self.export_messpunkt_layer),
                ('BAUTEN', self.export_bauten_layer),
                ('NETZTECHNIK', self.export_netztechnik_layer),
                ('ENDVERBRAUCHER', self.export_endverbraucher_layer),
                ('Leerrohre', self.export_leerrohre_layer),
                ('LINIEN', self.export_linien_layer),
                ('TRASSENBAU', self.export_trassenbau_layer),
                ('MITVERLEGUNG', self.export_mitverlegung_layer),
                ('Verbindungen', self.export_verbindungen_layer),
                ('REL_DOKU_KABEL_ROHR', self.export_rel_doku_kabel_rohr_layer),
            ]
            
            # Setup progress bar
            from qgis.PyQt.QtWidgets import QProgressBar
            from qgis.PyQt.QtCore import Qt
            
            progressMessageBar = self.iface.messageBar().createMessage(f"Exporting layers for Job ID: {job_id}...")
            progress = QProgressBar()
            progress.setMaximum(len(layers_to_export))
            progress.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            progressMessageBar.layout().addWidget(progress)
            self.iface.messageBar().pushWidget(progressMessageBar)
            
            # Export each layer with progress update
            for i, (layer_name, export_func) in enumerate(layers_to_export):
                progress.setValue(i)
                progressMessageBar.setText(f"Exporting {layer_name}...")
                # Process events to update UI
                from qgis.PyQt.QtWidgets import QApplication
                QApplication.processEvents()
                
                result = export_func(job_id, output_folder)
                if result:
                    export_results.append(result)
            
            # Complete progress
            progress.setValue(len(layers_to_export))
            self.iface.messageBar().clearWidgets()
            
            # === GEODATABASE EXPORT ===
            gdb_exporter = GDBExporter(self.plugin_dir)
            
            # Copy template geodatabase
            try:
                gdb_path = gdb_exporter.copy_template_gdb(output_folder, job_id)
                
                # Export PUNKT to geodatabase
                gdb_result = gdb_exporter.export_punkt_to_gdb(job_id, gdb_path)
                if gdb_result:
                    export_results.append(gdb_result)
                
                # Export ROHRMUFFE to geodatabase
                gdb_result = gdb_exporter.export_rohrmuffe_to_gdb(job_id, gdb_path)
                if gdb_result:
                    export_results.append(gdb_result)
                
                # Export MESSPUNKT to geodatabase
                gdb_result = gdb_exporter.export_messpunkt_to_gdb(job_id, gdb_path)
                if gdb_result:
                    export_results.append(gdb_result)
                
                # Export BAUTEN to geodatabase
                gdb_result = gdb_exporter.export_bauten_to_gdb(job_id, gdb_path)
                if gdb_result:
                    export_results.append(gdb_result)
                
                # Export NETZTECHNIK to geodatabase
                gdb_result = gdb_exporter.export_netztechnik_to_gdb(job_id, gdb_path)
                if gdb_result:
                    export_results.append(gdb_result)
                
                # Export ENDVERBRAUCHER to geodatabase
                gdb_result = gdb_exporter.export_endverbraucher_to_gdb(job_id, gdb_path)
                if gdb_result:
                    export_results.append(gdb_result)
                
                # Export Leerrohre to geodatabase (COM_DOKU_ROHR)
                gdb_result = gdb_exporter.export_leerrohre_to_gdb(job_id, gdb_path)
                if gdb_result:
                    export_results.append(gdb_result)
                
                # Export Verbindungen to geodatabase (COM_DOKU_KABEL)
                gdb_result = gdb_exporter.export_verbindungen_to_gdb(job_id, gdb_path)
                if gdb_result:
                    export_results.append(gdb_result)
                    
            except Exception as e:
                export_results.append({
                    'layer': 'GDB Export',
                    'success': False,
                    'error': str(e)
                })
            
            # Show final summary dialog
            self.show_export_summary(export_results, job_id)
    
    def export_punkt_layer(self, job_id, output_folder):
        """Export PUNKT layer features filtered by job_id with display values"""
        try:
            # Find the PUNKT layer
            layers = QgsProject.instance().mapLayers()
            target_layer = None
            for layer_id, layer in layers.items():
                if layer.name().upper() == 'PUNKT':
                    target_layer = layer
                    break
            
            if not target_layer or not target_layer.isValid():
                return None
            
            # Check feature count with filter
            filter_expression = f'"job_id" = {job_id}'
            target_layer.setSubsetString(filter_expression)
            feature_count = target_layer.featureCount()
            
            if feature_count == 0:
                target_layer.setSubsetString('')
                return {'layer': 'PUNKT', 'success': False, 'no_data': True, 'error': f'No features found with job_id = {job_id}'}
            
            # Create fields with string type for value relation fields
            new_fields = []
            for field in target_layer.fields():
                field_idx = target_layer.fields().indexFromName(field.name())
                widget_setup = target_layer.editorWidgetSetup(field_idx)
                if widget_setup.type() == 'ValueRelation':
                    new_field = QgsField(field.name(), QVariant.String, 'String', 254)
                else:
                    new_field = QgsField(field)
                new_fields.append(new_field)
            
            # Create temporary memory layer
            geom_type = QgsWkbTypes.displayString(target_layer.wkbType())
            temp_layer = QgsVectorLayer(f"{geom_type}?crs={target_layer.crs().authid()}", "temp_punkt", "memory")
            temp_layer.dataProvider().addAttributes(new_fields)
            temp_layer.updateFields()
            temp_layer.startEditing()
            
            # Clear filter and build lookup cache
            target_layer.setSubsetString('')
            lookup_cache = self.build_lookup_cache(target_layer)
            
            # Process features with QgsFeatureRequest
            request = QgsFeatureRequest().setFilterExpression(f'job_id = {job_id}')
            for source_feature in target_layer.getFeatures(request):
                new_feature = QgsFeature(temp_layer.fields())
                new_feature.setGeometry(source_feature.geometry())
                
                for field in target_layer.fields():
                    field_name = field.name()
                    display_value = self.get_display_value_cached(source_feature, field_name, lookup_cache)
                    new_feature[field_name] = display_value
                
                temp_layer.addFeature(new_feature)
            
            temp_layer.commitChanges()
            
            # Export
            output_file = os.path.join(output_folder, f'PUNKT_job_{job_id}.shp')
            error = QgsVectorFileWriter.writeAsVectorFormat(temp_layer, output_file, 'UTF-8', temp_layer.crs(), 'ESRI Shapefile')
            
            if error[0] == QgsVectorFileWriter.NoError:
                return {'layer': 'PUNKT', 'count': temp_layer.featureCount(), 'file': output_file, 'success': True}
            else:
                return {'layer': 'PUNKT', 'success': False, 'error': error[1]}
                
        except Exception as e:
            return {'layer': 'PUNKT', 'success': False, 'error': str(e)}
    
    def export_rohrmuffe_layer(self, job_id, output_folder):
        """Export ROHRMUFFE layer features filtered by job_id with display values"""
        try:
            # Find the ROHRMUFFE layer
            layers = QgsProject.instance().mapLayers()
            target_layer = None
            for layer_id, layer in layers.items():
                if layer.name().upper() == 'ROHRMUFFE':
                    target_layer = layer
                    break
            
            if not target_layer or not target_layer.isValid():
                return None
            
            # Check feature count with filter
            filter_expression = f'"job_id" = {job_id}'
            target_layer.setSubsetString(filter_expression)
            feature_count = target_layer.featureCount()
            
            if feature_count == 0:
                target_layer.setSubsetString('')
                return {'layer': 'ROHRMUFFE', 'success': False, 'no_data': True, 'error': f'No features found with job_id = {job_id}'}
            
            # Create fields with string type for value relation fields
            new_fields = []
            for field in target_layer.fields():
                field_idx = target_layer.fields().indexFromName(field.name())
                widget_setup = target_layer.editorWidgetSetup(field_idx)
                if widget_setup.type() == 'ValueRelation':
                    new_field = QgsField(field.name(), QVariant.String, 'String', 254)
                else:
                    new_field = QgsField(field)
                new_fields.append(new_field)
            
            # Create temporary memory layer
            geom_type = QgsWkbTypes.displayString(target_layer.wkbType())
            temp_layer = QgsVectorLayer(f"{geom_type}?crs={target_layer.crs().authid()}", "temp_rohrmuffe", "memory")
            temp_layer.dataProvider().addAttributes(new_fields)
            temp_layer.updateFields()
            temp_layer.startEditing()
            
            # Clear filter and build lookup cache
            target_layer.setSubsetString('')
            lookup_cache = self.build_lookup_cache(target_layer)
            
            # Process features with QgsFeatureRequest
            request = QgsFeatureRequest().setFilterExpression(f'job_id = {job_id}')
            for source_feature in target_layer.getFeatures(request):
                new_feature = QgsFeature(temp_layer.fields())
                new_feature.setGeometry(source_feature.geometry())
                
                for field in target_layer.fields():
                    field_name = field.name()
                    display_value = self.get_display_value_cached(source_feature, field_name, lookup_cache)
                    new_feature[field_name] = display_value
                
                temp_layer.addFeature(new_feature)
            
            temp_layer.commitChanges()
            
            # Export
            output_file = os.path.join(output_folder, f'ROHRMUFFE_job_{job_id}.shp')
            error = QgsVectorFileWriter.writeAsVectorFormat(temp_layer, output_file, 'UTF-8', temp_layer.crs(), 'ESRI Shapefile')
            
            if error[0] == QgsVectorFileWriter.NoError:
                return {'layer': 'ROHRMUFFE', 'count': temp_layer.featureCount(), 'file': output_file, 'success': True}
            else:
                return {'layer': 'ROHRMUFFE', 'success': False, 'error': error[1]}
                
        except Exception as e:
            return {'layer': 'ROHRMUFFE', 'success': False, 'error': str(e)}
    
    def export_messpunkt_layer(self, job_id, output_folder):
        """Export MESSPUNKT layer features filtered by job_id with display values"""
        try:
            # Find the MESSPUNKT layer
            layers = QgsProject.instance().mapLayers()
            target_layer = None
            for layer_id, layer in layers.items():
                if layer.name().upper() == 'MESSPUNKT':
                    target_layer = layer
                    break
            
            if not target_layer or not target_layer.isValid():
                return None
            
            # Check feature count with filter
            filter_expression = f'"job_id" = {job_id}'
            target_layer.setSubsetString(filter_expression)
            feature_count = target_layer.featureCount()
            
            if feature_count == 0:
                target_layer.setSubsetString('')
                return {'layer': 'MESSPUNKT', 'success': False, 'no_data': True, 'error': f'No features found with job_id = {job_id}'}
            
            # Create fields with string type for value relation fields
            new_fields = []
            for field in target_layer.fields():
                field_idx = target_layer.fields().indexFromName(field.name())
                widget_setup = target_layer.editorWidgetSetup(field_idx)
                if widget_setup.type() == 'ValueRelation':
                    new_field = QgsField(field.name(), QVariant.String, 'String', 254)
                else:
                    new_field = QgsField(field)
                new_fields.append(new_field)
            
            # Create temporary memory layer
            geom_type = QgsWkbTypes.displayString(target_layer.wkbType())
            temp_layer = QgsVectorLayer(f"{geom_type}?crs={target_layer.crs().authid()}", "temp_messpunkt", "memory")
            temp_layer.dataProvider().addAttributes(new_fields)
            temp_layer.updateFields()
            temp_layer.startEditing()
            
            # Clear filter and build lookup cache
            target_layer.setSubsetString('')
            lookup_cache = self.build_lookup_cache(target_layer)
            
            # Process features with QgsFeatureRequest
            request = QgsFeatureRequest().setFilterExpression(f'job_id = {job_id}')
            for source_feature in target_layer.getFeatures(request):
                new_feature = QgsFeature(temp_layer.fields())
                new_feature.setGeometry(source_feature.geometry())
                
                for field in target_layer.fields():
                    field_name = field.name()
                    display_value = self.get_display_value_cached(source_feature, field_name, lookup_cache)
                    new_feature[field_name] = display_value
                
                temp_layer.addFeature(new_feature)
            
            temp_layer.commitChanges()
            
            # Export
            output_file = os.path.join(output_folder, f'MESSPUNKT_job_{job_id}.shp')
            error = QgsVectorFileWriter.writeAsVectorFormat(temp_layer, output_file, 'UTF-8', temp_layer.crs(), 'ESRI Shapefile')
            
            if error[0] == QgsVectorFileWriter.NoError:
                return {'layer': 'MESSPUNKT', 'count': temp_layer.featureCount(), 'file': output_file, 'success': True}
            else:
                return {'layer': 'MESSPUNKT', 'success': False, 'error': error[1]}
                
        except Exception as e:
            return {'layer': 'MESSPUNKT', 'success': False, 'error': str(e)}
    
    def get_value_relation_key(self, layer, field_name, display_value):
        """Get the key (ID) for a given display value in a ValueRelation field"""
        field_idx = layer.fields().indexFromName(field_name)
        if field_idx == -1:
            return None
        
        widget_setup = layer.editorWidgetSetup(field_idx)
        if widget_setup.type() == 'ValueRelation':
            config = widget_setup.config()
            relation_layer_id = config.get('Layer')
            key_field = config.get('Key')
            value_field = config.get('Value')
            
            if relation_layer_id and key_field and value_field:
                relation_layer = QgsProject.instance().mapLayer(relation_layer_id)
                if relation_layer:
                    # Find feature where value_field matches display_value
                    request = QgsFeatureRequest().setFilterExpression(f'"{value_field}" = \'{display_value}\'')
                    for rel_feature in relation_layer.getFeatures(request):
                        return rel_feature[key_field]
        
        return None
    
    def build_lookup_cache(self, layer):
        """Build a cache of all value relations for a layer (called once per layer)"""
        cache = {}  # {field_name: {key: value}}
        
        for field in layer.fields():
            field_name = field.name()
            field_idx = layer.fields().indexFromName(field_name)
            widget_setup = layer.editorWidgetSetup(field_idx)
            
            if widget_setup.type() == 'ValueRelation':
                config = widget_setup.config()
                relation_layer_id = config.get('Layer')
                key_field = config.get('Key')
                value_field = config.get('Value')
                
                if relation_layer_id and key_field and value_field:
                    relation_layer = QgsProject.instance().mapLayer(relation_layer_id)
                    if relation_layer:
                        # Build lookup dictionary for this field
                        # Store both original key and string key for flexible matching
                        lookup = {}
                        for rel_feature in relation_layer.getFeatures():
                            key = rel_feature[key_field]
                            value = rel_feature[value_field]
                            lookup[key] = value
                            # Also store string version of key
                            if key is not None:
                                lookup[str(key)] = value
                        cache[field_name] = lookup
        
        return cache
    
    def get_display_value_cached(self, feature, field_name, lookup_cache):
        """Get display value using pre-built cache (fast)"""
        value = feature[field_name]
        if value is None:
            return value
        if field_name in lookup_cache:
            # Try original value first, then string version
            if value in lookup_cache[field_name]:
                return lookup_cache[field_name][value]
            if str(value) in lookup_cache[field_name]:
                return lookup_cache[field_name][str(value)]
        return value
    
    def convert_feature_to_display_values(self, layer, feature):
        """Convert all field values in a feature to their display values"""
        new_feature = QgsFeature(feature)
        
        # Explicitly copy geometry
        if feature.hasGeometry():
            new_feature.setGeometry(feature.geometry())
        
        # Convert all field values to display values
        for field_idx, field in enumerate(layer.fields()):
            field_name = field.name()
            display_value = self.get_display_value(layer, feature, field_name)
            new_feature.setAttribute(field_idx, display_value)
        
        return new_feature
    
    def export_bauten_layer(self, job_id, output_folder):
        """Export BAUTEN layer features filtered by job_id, with display values and ART field modification"""
        try:
            layers = QgsProject.instance().mapLayers()
            target_layer = None
            for layer_id, layer in layers.items():
                if layer.name() == 'BAUTEN' or layer.name().upper() == 'BAUTEN':
                    target_layer = layer
                    break
            if not target_layer or not target_layer.isValid():
                return None
            
            # Apply filter based on job_id
            filter_expression = f'"job_id" = {job_id}'
            target_layer.setSubsetString(filter_expression)
            feature_count = target_layer.featureCount()
            
            if feature_count == 0:
                target_layer.setSubsetString('')
                return {'layer': 'BAUTEN', 'success': False, 'no_data': True, 'error': f'No features found with job_id = {job_id}'}
            
            # Create fields with string type for value relation fields
            new_fields = []
            for field in target_layer.fields():
                field_idx = target_layer.fields().indexFromName(field.name())
                widget_setup = target_layer.editorWidgetSetup(field_idx)
                if widget_setup.type() == 'ValueRelation':
                    new_field = QgsField(field.name(), QVariant.String, 'String', 254)
                else:
                    new_field = QgsField(field)
                new_fields.append(new_field)
            
            # Create temporary memory layer
            geom_type = QgsWkbTypes.displayString(target_layer.wkbType())
            temp_layer = QgsVectorLayer(f"{geom_type}?crs={target_layer.crs().authid()}", "temp_bauten", "memory")
            temp_layer.dataProvider().addAttributes(new_fields)
            temp_layer.updateFields()
            temp_layer.startEditing()
            
            # Clear any existing filter
            target_layer.setSubsetString('')
            
            # Build lookup cache ONCE for all value relations (huge performance boost)
            lookup_cache = self.build_lookup_cache(target_layer)
            
            # Use QgsFeatureRequest to filter features
            request = QgsFeatureRequest().setFilterExpression(f'job_id = {job_id}')
            
            # Process features directly (no need to convert to list first)
            for source_feature in target_layer.getFeatures(request):
                new_feature = QgsFeature(temp_layer.fields())
                new_feature.setGeometry(source_feature.geometry())
                
                # Convert all fields to display values using cache
                for field in target_layer.fields():
                    field_name = field.name()
                    display_value = self.get_display_value_cached(source_feature, field_name, lookup_cache)
                    new_feature[field_name] = display_value
                
                # If ART = 'Sonstiges', replace with ART_SONST value
                if new_feature['ART'] == 'Sonstiges':
                    art_sonst_value = new_feature['ART_SONST']
                    if art_sonst_value:
                        new_feature['ART'] = art_sonst_value
                
                temp_layer.addFeature(new_feature)
            
            temp_layer.commitChanges()
            
            # Export
            output_file = os.path.join(output_folder, f'BAUTEN_job_{job_id}.shp')
            error = QgsVectorFileWriter.writeAsVectorFormat(temp_layer, output_file, 'UTF-8', temp_layer.crs(), 'ESRI Shapefile')
            
            if error[0] == QgsVectorFileWriter.NoError:
                return {'layer': 'BAUTEN', 'count': temp_layer.featureCount(), 'file': output_file, 'success': True}
            else:
                return {'layer': 'BAUTEN', 'success': False, 'error': error[1]}
                
        except Exception as e:
            import traceback
            return {'layer': 'BAUTEN', 'success': False, 'error': f'{str(e)}\n{traceback.format_exc()}'}
    
    def export_netztechnik_layer(self, job_id, output_folder):
        """Export NETZTECHNIK layer features filtered by job_id with display values and ART_SONST logic"""
        try:
            # Find the NETZTECHNIK layer
            layers = QgsProject.instance().mapLayers()
            target_layer = None
            for layer_id, layer in layers.items():
                if layer.name().upper() == 'NETZTECHNIK':
                    target_layer = layer
                    break
            
            if not target_layer or not target_layer.isValid():
                return None
            
            # Check feature count with filter
            filter_expression = f'"job_id" = {job_id}'
            target_layer.setSubsetString(filter_expression)
            feature_count = target_layer.featureCount()
            
            if feature_count == 0:
                target_layer.setSubsetString('')
                return {'layer': 'NETZTECHNIK', 'success': False, 'no_data': True, 'error': f'No features found with job_id = {job_id}'}
            
            # Create fields with string type for value relation fields
            new_fields = []
            for field in target_layer.fields():
                field_idx = target_layer.fields().indexFromName(field.name())
                widget_setup = target_layer.editorWidgetSetup(field_idx)
                if widget_setup.type() == 'ValueRelation':
                    new_field = QgsField(field.name(), QVariant.String, 'String', 254)
                else:
                    new_field = QgsField(field)
                new_fields.append(new_field)
            
            # Create temporary memory layer
            geom_type = QgsWkbTypes.displayString(target_layer.wkbType())
            temp_layer = QgsVectorLayer(f"{geom_type}?crs={target_layer.crs().authid()}", "temp_netztechnik", "memory")
            temp_layer.dataProvider().addAttributes(new_fields)
            temp_layer.updateFields()
            temp_layer.startEditing()
            
            # Clear filter and build lookup cache
            target_layer.setSubsetString('')
            lookup_cache = self.build_lookup_cache(target_layer)
            
            # Process features with QgsFeatureRequest
            request = QgsFeatureRequest().setFilterExpression(f'job_id = {job_id}')
            for source_feature in target_layer.getFeatures(request):
                new_feature = QgsFeature(temp_layer.fields())
                new_feature.setGeometry(source_feature.geometry())
                
                for field in target_layer.fields():
                    field_name = field.name()
                    display_value = self.get_display_value_cached(source_feature, field_name, lookup_cache)
                    new_feature[field_name] = display_value
                
                # If ART = 'Sonstige', replace with ART_SONST value
                if new_feature['ART'] == 'Sonstige':
                    art_sonst_value = new_feature['ART_SONST']
                    if art_sonst_value:
                        new_feature['ART'] = art_sonst_value
                
                temp_layer.addFeature(new_feature)
            
            temp_layer.commitChanges()
            
            # Export
            output_file = os.path.join(output_folder, f'NETZTECHNIK_job_{job_id}.shp')
            error = QgsVectorFileWriter.writeAsVectorFormat(temp_layer, output_file, 'UTF-8', temp_layer.crs(), 'ESRI Shapefile')
            
            if error[0] == QgsVectorFileWriter.NoError:
                return {'layer': 'NETZTECHNIK', 'count': temp_layer.featureCount(), 'file': output_file, 'success': True}
            else:
                return {'layer': 'NETZTECHNIK', 'success': False, 'error': error[1]}
                
        except Exception as e:
            return {'layer': 'NETZTECHNIK', 'success': False, 'error': str(e)}
    
    def export_endverbraucher_layer(self, job_id, output_folder):
        """Export ENDVERBRAUCHER layer features filtered by job_id with display values"""
        try:
            # Find the ENDVERBRAUCHER layer
            layers = QgsProject.instance().mapLayers()
            target_layer = None
            for layer_id, layer in layers.items():
                if layer.name().upper() == 'ENDVERBRAUCHER':
                    target_layer = layer
                    break
            
            if not target_layer or not target_layer.isValid():
                return None
            
            # Check feature count with filter
            filter_expression = f'"job_id" = {job_id}'
            target_layer.setSubsetString(filter_expression)
            feature_count = target_layer.featureCount()
            
            if feature_count == 0:
                target_layer.setSubsetString('')
                return {'layer': 'ENDVERBRAUCHER', 'success': False, 'no_data': True, 'error': f'No features found with job_id = {job_id}'}
            
            # Create fields with string type for value relation fields
            new_fields = []
            for field in target_layer.fields():
                field_idx = target_layer.fields().indexFromName(field.name())
                widget_setup = target_layer.editorWidgetSetup(field_idx)
                if widget_setup.type() == 'ValueRelation':
                    new_field = QgsField(field.name(), QVariant.String, 'String', 254)
                else:
                    new_field = QgsField(field)
                new_fields.append(new_field)
            
            # Create temporary memory layer
            geom_type = QgsWkbTypes.displayString(target_layer.wkbType())
            temp_layer = QgsVectorLayer(f"{geom_type}?crs={target_layer.crs().authid()}", "temp_endverbraucher", "memory")
            temp_layer.dataProvider().addAttributes(new_fields)
            temp_layer.updateFields()
            temp_layer.startEditing()
            
            # Clear filter and build lookup cache
            target_layer.setSubsetString('')
            lookup_cache = self.build_lookup_cache(target_layer)
            
            # Process features with QgsFeatureRequest
            request = QgsFeatureRequest().setFilterExpression(f'job_id = {job_id}')
            for source_feature in target_layer.getFeatures(request):
                new_feature = QgsFeature(temp_layer.fields())
                new_feature.setGeometry(source_feature.geometry())
                
                for field in target_layer.fields():
                    field_name = field.name()
                    display_value = self.get_display_value_cached(source_feature, field_name, lookup_cache)
                    new_feature[field_name] = display_value
                
                temp_layer.addFeature(new_feature)
            
            temp_layer.commitChanges()
            
            # Export
            output_file = os.path.join(output_folder, f'ENDVERBRAUCHER_job_{job_id}.shp')
            error = QgsVectorFileWriter.writeAsVectorFormat(temp_layer, output_file, 'UTF-8', temp_layer.crs(), 'ESRI Shapefile')
            
            if error[0] == QgsVectorFileWriter.NoError:
                return {'layer': 'ENDVERBRAUCHER', 'count': temp_layer.featureCount(), 'file': output_file, 'success': True}
            else:
                return {'layer': 'ENDVERBRAUCHER', 'success': False, 'error': error[1]}
                
        except Exception as e:
            return {'layer': 'ENDVERBRAUCHER', 'success': False, 'error': str(e)}
    
    def export_leerrohre_layer(self, job_id, output_folder):
        """Export Leerrohre layer features filtered by job_id with display values"""
        try:
            # Find the Leerrohre layer
            layers = QgsProject.instance().mapLayers()
            target_layer = None
            for layer_id, layer in layers.items():
                if 'leerrohr' in layer.name().lower():
                    target_layer = layer
                    break
            
            if not target_layer or not target_layer.isValid():
                return {'layer': 'Leerrohre', 'success': False, 'error': 'Layer not found or invalid'}
            
            # Check feature count with filter
            filter_expression = f'"job_id" = {job_id}'
            target_layer.setSubsetString(filter_expression)
            feature_count = target_layer.featureCount()
            
            if feature_count == 0:
                target_layer.setSubsetString('')
                return {'layer': 'Leerrohre', 'success': False, 'no_data': True, 'error': f'No features found with job_id = {job_id}'}
            
            # Create fields with string type for value relation fields
            new_fields = []
            for field in target_layer.fields():
                field_idx = target_layer.fields().indexFromName(field.name())
                widget_setup = target_layer.editorWidgetSetup(field_idx)
                if widget_setup.type() == 'ValueRelation':
                    new_field = QgsField(field.name(), QVariant.String, 'String', 254)
                else:
                    new_field = QgsField(field)
                new_fields.append(new_field)
            
            # Create temporary memory layer
            geom_type = QgsWkbTypes.displayString(target_layer.wkbType())
            temp_layer = QgsVectorLayer(f"{geom_type}?crs={target_layer.crs().authid()}", "temp_leerrohre", "memory")
            temp_layer.dataProvider().addAttributes(new_fields)
            temp_layer.updateFields()
            temp_layer.startEditing()
            
            # Clear filter and build lookup cache
            target_layer.setSubsetString('')
            lookup_cache = self.build_lookup_cache(target_layer)
            
            # Process features with QgsFeatureRequest
            request = QgsFeatureRequest().setFilterExpression(f'job_id = {job_id}')
            for source_feature in target_layer.getFeatures(request):
                new_feature = QgsFeature(temp_layer.fields())
                new_feature.setGeometry(source_feature.geometry())
                
                for field in target_layer.fields():
                    field_name = field.name()
                    display_value = self.get_display_value_cached(source_feature, field_name, lookup_cache)
                    new_feature[field_name] = display_value
                
                # If LR_ART = 'Sonstige' or 'Sonstiges', replace with LR_SONST value
                if new_feature['LR_ART'] in ('Sonstige', 'Sonstiges'):
                    lr_sonst_value = new_feature['LR_SONST']
                    if lr_sonst_value:
                        new_feature['LR_ART'] = lr_sonst_value
                
                # If ER_FARB = 'Sonstige' or 'Sonstiges', replace with ER_FARB_SON value
                if new_feature['ER_FARB'] in ('Sonstige', 'Sonstiges'):
                    er_farb_son_value = new_feature['ER_FARB_SON']
                    if er_farb_son_value:
                        new_feature['ER_FARB'] = er_farb_son_value
                
                # If M_FARB = 'Sonstige' or 'Sonstiges', replace with M_FARB_SON value
                if new_feature['M_FARB'] in ('Sonstige', 'Sonstiges'):
                    m_farb_son_value = new_feature['M_FARB_SON']
                    if m_farb_son_value:
                        new_feature['M_FARB'] = m_farb_son_value
                
                # If LR_HERST = 'Sonstige' or 'Sonstiges', replace with LR_HER_SON value
                if new_feature['LR_HERST'] in ('Sonstige', 'Sonstiges'):
                    lr_her_son_value = new_feature['LR_HER_SON']
                    if lr_her_son_value:
                        new_feature['LR_HERST'] = lr_her_son_value
                
                temp_layer.addFeature(new_feature)
            
            temp_layer.commitChanges()
            
            # Export
            output_file = os.path.join(output_folder, f'Leerrohre_job_{job_id}.shp')
            error = QgsVectorFileWriter.writeAsVectorFormat(temp_layer, output_file, 'UTF-8', temp_layer.crs(), 'ESRI Shapefile')
            
            if error[0] == QgsVectorFileWriter.NoError:
                return {'layer': 'Leerrohre', 'count': temp_layer.featureCount(), 'file': output_file, 'success': True}
            else:
                return {'layer': 'Leerrohre', 'success': False, 'error': error[1]}
                
        except Exception as e:
            return {'layer': 'Leerrohre', 'success': False, 'error': str(e)}
    
    def export_linien_layer(self, job_id, output_folder):
        """Export LINIEN layer features filtered by job_id with display values"""
        try:
            # Find the LINIEN layer
            layers = QgsProject.instance().mapLayers()
            target_layer = None
            for layer_id, layer in layers.items():
                if layer.name().upper() == 'LINIEN':
                    target_layer = layer
                    break
            
            if not target_layer or not target_layer.isValid():
                return None
            
            # Check feature count with filter
            filter_expression = f'"job_id" = {job_id}'
            target_layer.setSubsetString(filter_expression)
            feature_count = target_layer.featureCount()
            
            if feature_count == 0:
                target_layer.setSubsetString('')
                return {'layer': 'LINIEN', 'success': False, 'no_data': True, 'error': f'No features found with job_id = {job_id}'}
            
            # Create fields with string type for value relation fields
            new_fields = []
            for field in target_layer.fields():
                field_idx = target_layer.fields().indexFromName(field.name())
                widget_setup = target_layer.editorWidgetSetup(field_idx)
                if widget_setup.type() == 'ValueRelation':
                    new_field = QgsField(field.name(), QVariant.String, 'String', 254)
                else:
                    new_field = QgsField(field)
                new_fields.append(new_field)
            
            # Create temporary memory layer
            geom_type = QgsWkbTypes.displayString(target_layer.wkbType())
            temp_layer = QgsVectorLayer(f"{geom_type}?crs={target_layer.crs().authid()}", "temp_linien", "memory")
            temp_layer.dataProvider().addAttributes(new_fields)
            temp_layer.updateFields()
            temp_layer.startEditing()
            
            # Clear filter and build lookup cache
            target_layer.setSubsetString('')
            lookup_cache = self.build_lookup_cache(target_layer)
            
            # Process features with QgsFeatureRequest
            request = QgsFeatureRequest().setFilterExpression(f'job_id = {job_id}')
            for source_feature in target_layer.getFeatures(request):
                new_feature = QgsFeature(temp_layer.fields())
                new_feature.setGeometry(source_feature.geometry())
                
                for field in target_layer.fields():
                    field_name = field.name()
                    display_value = self.get_display_value_cached(source_feature, field_name, lookup_cache)
                    new_feature[field_name] = display_value
                
                temp_layer.addFeature(new_feature)
            
            temp_layer.commitChanges()
            
            # Export
            output_file = os.path.join(output_folder, f'LINIEN_job_{job_id}.shp')
            error = QgsVectorFileWriter.writeAsVectorFormat(temp_layer, output_file, 'UTF-8', temp_layer.crs(), 'ESRI Shapefile')
            
            if error[0] == QgsVectorFileWriter.NoError:
                return {'layer': 'LINIEN', 'count': temp_layer.featureCount(), 'file': output_file, 'success': True}
            else:
                return {'layer': 'LINIEN', 'success': False, 'error': error[1]}
                
        except Exception as e:
            return {'layer': 'LINIEN', 'success': False, 'error': str(e)}
    
    def export_trassenbau_layer(self, job_id, output_folder):
        """Export TRASSENBAU layer features filtered by job_id with display values"""
        try:
            # Find the TRASSENBAU layer
            layers = QgsProject.instance().mapLayers()
            target_layer = None
            for layer_id, layer in layers.items():
                if layer.name().upper() == 'TRASSENBAU':
                    target_layer = layer
                    break
            
            if not target_layer or not target_layer.isValid():
                return None
            
            # Check feature count with filter
            filter_expression = f'"job_id" = {job_id}'
            target_layer.setSubsetString(filter_expression)
            feature_count = target_layer.featureCount()
            
            if feature_count == 0:
                target_layer.setSubsetString('')
                return {'layer': 'TRASSENBAU', 'success': False, 'no_data': True, 'error': f'No features found with job_id = {job_id}'}
            
            # Create fields with string type for value relation fields
            new_fields = []
            for field in target_layer.fields():
                field_idx = target_layer.fields().indexFromName(field.name())
                widget_setup = target_layer.editorWidgetSetup(field_idx)
                if widget_setup.type() == 'ValueRelation':
                    new_field = QgsField(field.name(), QVariant.String, 'String', 254)
                else:
                    new_field = QgsField(field)
                new_fields.append(new_field)
            
            # Create temporary memory layer
            geom_type = QgsWkbTypes.displayString(target_layer.wkbType())
            temp_layer = QgsVectorLayer(f"{geom_type}?crs={target_layer.crs().authid()}", "temp_trassenbau", "memory")
            temp_layer.dataProvider().addAttributes(new_fields)
            temp_layer.updateFields()
            temp_layer.startEditing()
            
            # Clear filter and build lookup cache
            target_layer.setSubsetString('')
            lookup_cache = self.build_lookup_cache(target_layer)
            
            # Process features with QgsFeatureRequest
            request = QgsFeatureRequest().setFilterExpression(f'job_id = {job_id}')
            for source_feature in target_layer.getFeatures(request):
                new_feature = QgsFeature(temp_layer.fields())
                new_feature.setGeometry(source_feature.geometry())
                
                for field in target_layer.fields():
                    field_name = field.name()
                    display_value = self.get_display_value_cached(source_feature, field_name, lookup_cache)
                    new_feature[field_name] = display_value
                
                temp_layer.addFeature(new_feature)
            
            temp_layer.commitChanges()
            
            # Export
            output_file = os.path.join(output_folder, f'TRASSENBAU_job_{job_id}.shp')
            error = QgsVectorFileWriter.writeAsVectorFormat(temp_layer, output_file, 'UTF-8', temp_layer.crs(), 'ESRI Shapefile')
            
            if error[0] == QgsVectorFileWriter.NoError:
                return {'layer': 'TRASSENBAU', 'count': temp_layer.featureCount(), 'file': output_file, 'success': True}
            else:
                return {'layer': 'TRASSENBAU', 'success': False, 'error': error[1]}
                
        except Exception as e:
            return {'layer': 'TRASSENBAU', 'success': False, 'error': str(e)}
    
    def export_mitverlegung_layer(self, job_id, output_folder):
        """Export MITVERLEGUNG layer features filtered by job_id with display values"""
        try:
            # Find the MITVERLEGUNG layer
            layers = QgsProject.instance().mapLayers()
            target_layer = None
            for layer_id, layer in layers.items():
                if layer.name().upper() == 'MITVERLEGUNG':
                    target_layer = layer
                    break
            
            if not target_layer or not target_layer.isValid():
                return None
            
            # Check feature count with filter
            filter_expression = f'"job_id" = {job_id}'
            target_layer.setSubsetString(filter_expression)
            feature_count = target_layer.featureCount()
            
            if feature_count == 0:
                target_layer.setSubsetString('')
                return {'layer': 'MITVERLEGUNG', 'success': False, 'no_data': True, 'error': f'No features found with job_id = {job_id}'}
            
            # Create fields with string type for value relation fields
            new_fields = []
            for field in target_layer.fields():
                field_idx = target_layer.fields().indexFromName(field.name())
                widget_setup = target_layer.editorWidgetSetup(field_idx)
                if widget_setup.type() == 'ValueRelation':
                    new_field = QgsField(field.name(), QVariant.String, 'String', 254)
                else:
                    new_field = QgsField(field)
                new_fields.append(new_field)
            
            # Create temporary memory layer
            geom_type = QgsWkbTypes.displayString(target_layer.wkbType())
            temp_layer = QgsVectorLayer(f"{geom_type}?crs={target_layer.crs().authid()}", "temp_mitverlegung", "memory")
            temp_layer.dataProvider().addAttributes(new_fields)
            temp_layer.updateFields()
            temp_layer.startEditing()
            
            # Clear filter and build lookup cache
            target_layer.setSubsetString('')
            lookup_cache = self.build_lookup_cache(target_layer)
            
            # Process features with QgsFeatureRequest
            request = QgsFeatureRequest().setFilterExpression(f'job_id = {job_id}')
            for source_feature in target_layer.getFeatures(request):
                new_feature = QgsFeature(temp_layer.fields())
                new_feature.setGeometry(source_feature.geometry())
                
                for field in target_layer.fields():
                    field_name = field.name()
                    display_value = self.get_display_value_cached(source_feature, field_name, lookup_cache)
                    new_feature[field_name] = display_value
                
                temp_layer.addFeature(new_feature)
            
            temp_layer.commitChanges()
            
            # Export
            output_file = os.path.join(output_folder, f'MITVERLEGUNG_job_{job_id}.shp')
            error = QgsVectorFileWriter.writeAsVectorFormat(temp_layer, output_file, 'UTF-8', temp_layer.crs(), 'ESRI Shapefile')
            
            if error[0] == QgsVectorFileWriter.NoError:
                return {'layer': 'MITVERLEGUNG', 'count': temp_layer.featureCount(), 'file': output_file, 'success': True}
            else:
                return {'layer': 'MITVERLEGUNG', 'success': False, 'error': error[1]}
                
        except Exception as e:
            return {'layer': 'MITVERLEGUNG', 'success': False, 'error': str(e)}
    
    def export_verbindungen_layer(self, job_id, output_folder):
        """Export Verbindungen layer features filtered by job_id with display values and Sonstige logic"""
        try:
            # Find the Verbindungen layer
            layers = QgsProject.instance().mapLayers()
            target_layer = None
            for layer_id, layer in layers.items():
                if 'verbindung' in layer.name().lower():
                    target_layer = layer
                    break
            
            if not target_layer or not target_layer.isValid():
                return {'layer': 'Verbindungen', 'success': False, 'error': 'Layer not found or invalid'}
            
            # Check feature count with filter
            filter_expression = f'"job_id" = {job_id}'
            target_layer.setSubsetString(filter_expression)
            feature_count = target_layer.featureCount()
            
            if feature_count == 0:
                target_layer.setSubsetString('')
                return {'layer': 'Verbindungen', 'success': False, 'no_data': True, 'error': f'No features found with job_id = {job_id}'}
            
            # Create fields with string type for value relation fields
            new_fields = []
            for field in target_layer.fields():
                field_idx = target_layer.fields().indexFromName(field.name())
                widget_setup = target_layer.editorWidgetSetup(field_idx)
                if widget_setup.type() == 'ValueRelation':
                    new_field = QgsField(field.name(), QVariant.String, 'String', 254)
                else:
                    new_field = QgsField(field)
                new_fields.append(new_field)
            
            # Create temporary memory layer
            geom_type = QgsWkbTypes.displayString(target_layer.wkbType())
            temp_layer = QgsVectorLayer(f"{geom_type}?crs={target_layer.crs().authid()}", "temp_verbindungen", "memory")
            temp_layer.dataProvider().addAttributes(new_fields)
            temp_layer.updateFields()
            temp_layer.startEditing()
            
            # Clear filter and build lookup cache
            target_layer.setSubsetString('')
            lookup_cache = self.build_lookup_cache(target_layer)
            
            # Process features with QgsFeatureRequest
            request = QgsFeatureRequest().setFilterExpression(f'job_id = {job_id}')
            for source_feature in target_layer.getFeatures(request):
                new_feature = QgsFeature(temp_layer.fields())
                new_feature.setGeometry(source_feature.geometry())
                
                for field in target_layer.fields():
                    field_name = field.name()
                    display_value = self.get_display_value_cached(source_feature, field_name, lookup_cache)
                    new_feature[field_name] = display_value
                
                # If VERB_ART = 'Sonstige' or 'Sonstiges', replace with V_A_SONST value
                if new_feature['VERB_ART'] in ('Sonstige', 'Sonstiges'):
                    v_a_sonst_value = new_feature['V_A_SONST']
                    if v_a_sonst_value:
                        new_feature['VERB_ART'] = v_a_sonst_value
                
                # # If ER_FARB = 'Sonstige' or 'Sonstiges', replace with ER_FARB_SON value
                # if new_feature['ER_FARB'] in ('Sonstige', 'Sonstiges'):
                #     er_farb_son_value = new_feature['ER_FARB_SON']
                #     if er_farb_son_value:
                #         new_feature['ER_FARB'] = er_farb_son_value
                
                temp_layer.addFeature(new_feature)
            
            temp_layer.commitChanges()
            
            # Export
            output_file = os.path.join(output_folder, f'Verbindungen_job_{job_id}.shp')
            error = QgsVectorFileWriter.writeAsVectorFormat(temp_layer, output_file, 'UTF-8', temp_layer.crs(), 'ESRI Shapefile')
            
            if error[0] == QgsVectorFileWriter.NoError:
                return {'layer': 'Verbindungen', 'count': temp_layer.featureCount(), 'file': output_file, 'success': True}
            else:
                return {'layer': 'Verbindungen', 'success': False, 'error': error[1]}
                
        except Exception as e:
            return {'layer': 'Verbindungen', 'success': False, 'error': str(e)}
    
    def export_rel_doku_kabel_rohr_layer(self, job_id, output_folder):
        """Export REL_DOKU_KABEL_ROHR table (no geometry) filtered by job_id with display values"""
        try:
            # Find the REL_DOKU_KABEL_ROHR layer
            layers = QgsProject.instance().mapLayers()
            target_layer = None
            for layer_id, layer in layers.items():
                if 'rel_doku_kabel_rohr' in layer.name().lower():
                    target_layer = layer
                    break
            
            if not target_layer or not target_layer.isValid():
                return {'layer': 'REL_DOKU_KABEL_ROHR', 'success': False, 'error': 'Layer not found or invalid'}
            
            # Check feature count with filter
            filter_expression = f'"job_id" = {job_id}'
            target_layer.setSubsetString(filter_expression)
            feature_count = target_layer.featureCount()
            
            if feature_count == 0:
                target_layer.setSubsetString('')
                return {'layer': 'REL_DOKU_KABEL_ROHR', 'success': False, 'no_data': True, 'error': f'No features found with job_id = {job_id}'}
            
            # Create fields with string type for value relation fields
            new_fields = []
            for field in target_layer.fields():
                field_idx = target_layer.fields().indexFromName(field.name())
                widget_setup = target_layer.editorWidgetSetup(field_idx)
                if widget_setup.type() == 'ValueRelation':
                    new_field = QgsField(field.name(), QVariant.String, 'String', 254)
                else:
                    new_field = QgsField(field)
                new_fields.append(new_field)
            
            # Create temporary memory layer (no geometry)
            temp_layer = QgsVectorLayer("None", "temp_rel_doku_kabel_rohr", "memory")
            temp_layer.dataProvider().addAttributes(new_fields)
            temp_layer.updateFields()
            temp_layer.startEditing()
            
            # Clear filter and build lookup cache
            target_layer.setSubsetString('')
            lookup_cache = self.build_lookup_cache(target_layer)
            
            # Process features with QgsFeatureRequest
            request = QgsFeatureRequest().setFilterExpression(f'job_id = {job_id}')
            for source_feature in target_layer.getFeatures(request):
                new_feature = QgsFeature(temp_layer.fields())
                
                for field in target_layer.fields():
                    field_name = field.name()
                    display_value = self.get_display_value_cached(source_feature, field_name, lookup_cache)
                    new_feature[field_name] = display_value
                
                temp_layer.addFeature(new_feature)
            
            temp_layer.commitChanges()
            
            # Export to CSV (best for importing into ArcGIS geodatabase tables)
            output_file = os.path.join(output_folder, f'REL_DOKU_KABEL_ROHR_job_{job_id}.csv')
            
            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = 'CSV'
            options.fileEncoding = 'UTF-8'
            options.layerOptions = ['SEPARATOR=SEMICOLON']
            
            error = QgsVectorFileWriter.writeAsVectorFormatV3(temp_layer, output_file, QgsCoordinateTransformContext(), options)
            
            if error[0] == QgsVectorFileWriter.NoError:
                return {'layer': 'REL_DOKU_KABEL_ROHR', 'count': temp_layer.featureCount(), 'file': output_file, 'success': True}
            else:
                return {'layer': 'REL_DOKU_KABEL_ROHR', 'success': False, 'error': error[1]}
                
        except Exception as e:
            return {'layer': 'REL_DOKU_KABEL_ROHR', 'success': False, 'error': str(e)}
    
    def show_export_summary(self, export_results, job_id):
        """Show summary dialog with all export results"""
        
        if not export_results:
            QMessageBox.warning(
                self.iface.mainWindow(),
                'Export Complete',
                'No layers were exported.'
            )
            return
        
        # Separate successful, failed, and no-data exports
        successful = [r for r in export_results if r.get('success')]
        no_data = [r for r in export_results if r.get('no_data')]
        failed = [r for r in export_results if not r.get('success') and not r.get('no_data')]
        
        # Build message
        message_parts = []
        
        if successful:
            message_parts.append(f"Successfully exported {len(successful)} layer(s) for Job ID: {job_id}\n")
            message_parts.append("=" * 50)
            for result in successful:
                layer_name = result['layer']
                count = result['count']
                filename = os.path.basename(result['file'])
                message_parts.append(f"\n {layer_name}: {count} features  {filename}")
        
        if no_data:
            if successful:
                message_parts.append("\n\n" + "=" * 50)
            message_parts.append(f"\n\nLayers with no data for Job ID {job_id} ({len(no_data)}):")
            for result in no_data:
                layer_name = result['layer']
                message_parts.append(f"\n {layer_name}: No features digitized")
        
        if failed:
            if successful or no_data:
                message_parts.append("\n\n" + "=" * 50)
            message_parts.append(f"\n\nFailed exports ({len(failed)}):")
            for result in failed:
                layer_name = result['layer']
                error = result.get('error', 'Unknown error')
                message_parts.append(f"\n {layer_name}: {error}")
        
        message = '\n'.join(message_parts)
        
        # Show appropriate message box
        if not successful and (failed or no_data):
            # No successful exports
            if failed:
                QMessageBox.critical(
                    self.iface.mainWindow(),
                    'Export Failed',
                    message
                )
            else:
                QMessageBox.information(
                    self.iface.mainWindow(),
                    'No Data to Export',
                    message
                )
        elif failed and successful:
            QMessageBox.warning(
                self.iface.mainWindow(),
                'Export Completed with Errors',
                message
            )
        else:
            QMessageBox.information(
                self.iface.mainWindow(),
                'Export Successful',
                message
            )
